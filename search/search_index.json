{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AR gorithm ARgorithm is a project aimed to provide educators and enthusiasts a tool to create AR visualizations explaining the workings of data structures and algorithms with ease. In recent times , there has been a rise in interest in programming education and this tool is designed to bring Augmented reality into the mix by making it easy to design dynamic and complex visualizations in augmented reality that are accessible to everyone free of cost. How does it work ? The project consists of three parts toolkit Server Mobile application The toolkit package is for developers who want to transport their own algorithms into augmented reality. The toolkit provides you with a template library which works just like your usual template library except this one records states . Each state is an event that occurs in your data structure and by keeping track of the states of your variables , data structures etc we then render them in augmented reality. The server takes the ARgorithm and runs it with custom user input to generate states which the mobile application converts to AR visualizations. The code used to create these visualizations is called argorithm . The people interacting with the project have been classified into programmer and user . The programmer creates and manages argorithm. The user interact with augmented reality visualizations of argorithm .","title":"Home"},{"location":"CHANGELOG/","text":"0.0.12 \u00b6 Linkedlist and DoublyLinkedList have been implemented Command line interface migrated from argparse and wasabi to Typer Shifted documentation from sphinx to mkdocs for better functionality 0.0.11 \u00b6 CLI now can be configured to connect to Server endpoint of choice Documentation pages added Introduction to ARgorithm Server Setup Getting started Alabaster theme for RTD customized 0.0.10 \u00b6 Following Data structures implemented Strings Vector Arrays (one-dimensional as well as multidimensional) Queue Stack Priority Queue Command line interface ready for basic server commands as well helper commands for ARgorithm Creation Programmer actions supported Server admin actions added Documentation Generated from doc strings and hosted","title":"Releases"},{"location":"CHANGELOG/#0012","text":"Linkedlist and DoublyLinkedList have been implemented Command line interface migrated from argparse and wasabi to Typer Shifted documentation from sphinx to mkdocs for better functionality","title":"0.0.12"},{"location":"CHANGELOG/#0011","text":"CLI now can be configured to connect to Server endpoint of choice Documentation pages added Introduction to ARgorithm Server Setup Getting started Alabaster theme for RTD customized","title":"0.0.11"},{"location":"CHANGELOG/#0010","text":"Following Data structures implemented Strings Vector Arrays (one-dimensional as well as multidimensional) Queue Stack Priority Queue Command line interface ready for basic server commands as well helper commands for ARgorithm Creation Programmer actions supported Server admin actions added Documentation Generated from doc strings and hosted","title":"0.0.10"},{"location":"cli/","text":"Command line interface \u00b6 The command line interface for ARgorithmToolkit helps programmers to create and manage their argorithms along with control and manage their server. $ ARgorithm --help Usage: ARgorithm [OPTIONS] COMMAND [ARGS]... ARgorithm CLI Options: -l, --local Connects to server running on localhost --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Configure \u00b6 This command can be used to set your own server IP. All your requests will be sent to this IP. If you are running server locally you dont need to configure IP, instead you can use the -l or --local flag to connect to local servers. Info when using the local flag before use it before the command $ ARgorithm --local [ COMMAND ] $ ARgorithm configure # Enter server endpoint :$ http://myserverendpoint.com [SUCCESS]: CONNECTED Cloud requests will now go to http://myserverendpoint.com Account \u00b6 This command can only be used if the server you are connected to has authorization feature enabled. Refer the configuration section in server setup to learn more about authentication and authorization setup. The account command consists of two subcommands which are shown below New \u00b6 The new subcommand in account creates a new account in the server. The email you will use will be registered as both programmer account and user account. Learn more here . $ ARgorithm account new # Enter email address:$ sample@user.com [INFO]: PASSWORD CRITERIA - between 8 to 25 characters - contains atleast one number - contains atleast lower case alphabet - contains atleast uppercase alphabet # Enter password:$ ******** # Repeat for confirmation:$ ********* [SUCCESS]: ACCOUNT CREATED These credentials will be used as both programmer and user credentials Login \u00b6 The login command can be used to login to your server. Once logged in, these credentials will be used when you interact with the server. $ ARgorithm account login # Enter email address:$ sample@user.com # Enter password:$ ******** [SUCCESS]: LOGGED IN SUCCESSFULLY Info If you are already logged in and you want to login using different credentials,use the -o or --override flag after login command. Init \u00b6 The init command is used to generate templates for ARgorithm. It creates a code file .py and a config file .config.json . $ ARgorithm init hello_world Creating empty template for hello_world [SUCCESS]: TEMPLATE GENERATED refer documentation at https://argorithm.github.io/toolkit/ to learn how to use it chech out examples at https://github.com/ARgorithm/toolkit/tree/master/examples $ ls hello_world.config.json hello_world.py The files generated are shown below hello_world.py import ARgorithmToolkit def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () # # Your code # return algo hello_world.config.json { \"argorithmID\" : \"hello_world\" , \"file\" : \"hello_world.py\" , \"function\" : \"run\" , \"parameters\" : {}, \"default\" : {}, \"description\" : \"\" } Submit \u00b6 The submit command is used to submit new ARgorithm to server. This comand takes the name of the argorithm for eg: fibonacci . In this case , it will search for fibonacci.py and fibonacci.config.json and after verification send them to server. $ ARgorithm submit fibonacci [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED List \u00b6 The list command can be used to check what all ARgorithms are available in server. When AUTH is enabled, it shows the programmer email that created it, if not it shows the admin email. $ ARgorithm list - fibonacci by sample@user.com Parameters n : int Update \u00b6 The update command is used to overwrite/update pre-existing ARgorithm with different code or/and configuration. If AUTH is enabled, then ARgorithm can only be updated by its author or by a programmer with admin priveleges. $ ARgorithm update fibonacci [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED Test \u00b6 The test command is used to run the argorithms in the server and observe the states. Here the states are not being printed as that can be long output. You can print the the states in json format using the --output or -o option. $ ARgorithm test fibonacci Found argorithm - fibonacci by sample@user.com Parameters n : int ---------------STATES--------------------------- Delete \u00b6 The delete command is used to delete ARgorithm from server. If AUTH is enabled, then ARgorithm can only be deleted by its author or by a programmer with admin priveleges. ARgorithm delete fibonacci Found argorithm - fibonacci by sample@user.com Parameters n : int # Are you sure you want to delete it [ y/N ] :$ y [INFO]: DELETED SUCCESSFULLY Admin \u00b6 The admin command like the account command can only be used if the server has authentication and authorization enabled. This command also has the added requirement that the programmer logged in must have admin priveleges. The subcommands under this command are used to manage accounts. Grant \u00b6 The grant subcommand is used to grant other programmer accounts admin access. Blacklisted accounts cannot be granted admin priveleges. $ ARgorithm admin grant sample@user.com [SUCCESS]: GRANTED ADMIN PRIVELEGES Revoke \u00b6 The revoke subcommand is used to take away admin access from programmer accounts. $ ARgorithm admin revoke sample@user.com [SUCCESS]: REVOKED ADMIN PRIVELEGES Blacklist \u00b6 The blacklist command can be used to block programmer accounts from submitting and testing ARgorithms and user accounts from running ARgorithms. This command can be used to handle cases of misconduct with server. $ ARgorithm admin blacklist sample@user.com [SUCCESS]: BLACKLISTED ACCOUNT Whitelist \u00b6 The whitelist command can be used to whitelist previously blacklisted accounts. $ ARgorithm admin whitelist sample@user.com [SUCCESS]: WHITELISTED ACCOUNT Delete \u00b6 Info This delete is different from delete command as this is a subcommand to the admin command $ ARgorithm admin delete [ USER ] and that is to delete argorithms $ ARgorithm delete [ ARGORITHM ] $ ARgorithm admin delete sample@user.com [SUCCESS]: DELETED ACCOUNT By default, this subcommand only deletes the user account (Refer here ). To delete the progammer account as well use the -p or --programmer flag. Warning It is not recommended to delete programmer accounts. Programmer accounts are useful for finding authors of ARgorithm. Try blacklist instead","title":"Command Line Interface"},{"location":"cli/#command-line-interface","text":"The command line interface for ARgorithmToolkit helps programmers to create and manage their argorithms along with control and manage their server. $ ARgorithm --help Usage: ARgorithm [OPTIONS] COMMAND [ARGS]... ARgorithm CLI Options: -l, --local Connects to server running on localhost --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Command line interface"},{"location":"cli/#configure","text":"This command can be used to set your own server IP. All your requests will be sent to this IP. If you are running server locally you dont need to configure IP, instead you can use the -l or --local flag to connect to local servers. Info when using the local flag before use it before the command $ ARgorithm --local [ COMMAND ] $ ARgorithm configure # Enter server endpoint :$ http://myserverendpoint.com [SUCCESS]: CONNECTED Cloud requests will now go to http://myserverendpoint.com","title":"Configure"},{"location":"cli/#account","text":"This command can only be used if the server you are connected to has authorization feature enabled. Refer the configuration section in server setup to learn more about authentication and authorization setup. The account command consists of two subcommands which are shown below","title":"Account"},{"location":"cli/#new","text":"The new subcommand in account creates a new account in the server. The email you will use will be registered as both programmer account and user account. Learn more here . $ ARgorithm account new # Enter email address:$ sample@user.com [INFO]: PASSWORD CRITERIA - between 8 to 25 characters - contains atleast one number - contains atleast lower case alphabet - contains atleast uppercase alphabet # Enter password:$ ******** # Repeat for confirmation:$ ********* [SUCCESS]: ACCOUNT CREATED These credentials will be used as both programmer and user credentials","title":"New"},{"location":"cli/#login","text":"The login command can be used to login to your server. Once logged in, these credentials will be used when you interact with the server. $ ARgorithm account login # Enter email address:$ sample@user.com # Enter password:$ ******** [SUCCESS]: LOGGED IN SUCCESSFULLY Info If you are already logged in and you want to login using different credentials,use the -o or --override flag after login command.","title":"Login"},{"location":"cli/#init","text":"The init command is used to generate templates for ARgorithm. It creates a code file .py and a config file .config.json . $ ARgorithm init hello_world Creating empty template for hello_world [SUCCESS]: TEMPLATE GENERATED refer documentation at https://argorithm.github.io/toolkit/ to learn how to use it chech out examples at https://github.com/ARgorithm/toolkit/tree/master/examples $ ls hello_world.config.json hello_world.py The files generated are shown below hello_world.py import ARgorithmToolkit def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () # # Your code # return algo hello_world.config.json { \"argorithmID\" : \"hello_world\" , \"file\" : \"hello_world.py\" , \"function\" : \"run\" , \"parameters\" : {}, \"default\" : {}, \"description\" : \"\" }","title":"Init"},{"location":"cli/#submit","text":"The submit command is used to submit new ARgorithm to server. This comand takes the name of the argorithm for eg: fibonacci . In this case , it will search for fibonacci.py and fibonacci.config.json and after verification send them to server. $ ARgorithm submit fibonacci [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED","title":"Submit"},{"location":"cli/#list","text":"The list command can be used to check what all ARgorithms are available in server. When AUTH is enabled, it shows the programmer email that created it, if not it shows the admin email. $ ARgorithm list - fibonacci by sample@user.com Parameters n : int","title":"List"},{"location":"cli/#update","text":"The update command is used to overwrite/update pre-existing ARgorithm with different code or/and configuration. If AUTH is enabled, then ARgorithm can only be updated by its author or by a programmer with admin priveleges. $ ARgorithm update fibonacci [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED","title":"Update"},{"location":"cli/#test","text":"The test command is used to run the argorithms in the server and observe the states. Here the states are not being printed as that can be long output. You can print the the states in json format using the --output or -o option. $ ARgorithm test fibonacci Found argorithm - fibonacci by sample@user.com Parameters n : int ---------------STATES---------------------------","title":"Test"},{"location":"cli/#delete","text":"The delete command is used to delete ARgorithm from server. If AUTH is enabled, then ARgorithm can only be deleted by its author or by a programmer with admin priveleges. ARgorithm delete fibonacci Found argorithm - fibonacci by sample@user.com Parameters n : int # Are you sure you want to delete it [ y/N ] :$ y [INFO]: DELETED SUCCESSFULLY","title":"Delete"},{"location":"cli/#admin","text":"The admin command like the account command can only be used if the server has authentication and authorization enabled. This command also has the added requirement that the programmer logged in must have admin priveleges. The subcommands under this command are used to manage accounts.","title":"Admin"},{"location":"cli/#grant","text":"The grant subcommand is used to grant other programmer accounts admin access. Blacklisted accounts cannot be granted admin priveleges. $ ARgorithm admin grant sample@user.com [SUCCESS]: GRANTED ADMIN PRIVELEGES","title":"Grant"},{"location":"cli/#revoke","text":"The revoke subcommand is used to take away admin access from programmer accounts. $ ARgorithm admin revoke sample@user.com [SUCCESS]: REVOKED ADMIN PRIVELEGES","title":"Revoke"},{"location":"cli/#blacklist","text":"The blacklist command can be used to block programmer accounts from submitting and testing ARgorithms and user accounts from running ARgorithms. This command can be used to handle cases of misconduct with server. $ ARgorithm admin blacklist sample@user.com [SUCCESS]: BLACKLISTED ACCOUNT","title":"Blacklist"},{"location":"cli/#whitelist","text":"The whitelist command can be used to whitelist previously blacklisted accounts. $ ARgorithm admin whitelist sample@user.com [SUCCESS]: WHITELISTED ACCOUNT","title":"Whitelist"},{"location":"cli/#delete_1","text":"Info This delete is different from delete command as this is a subcommand to the admin command $ ARgorithm admin delete [ USER ] and that is to delete argorithms $ ARgorithm delete [ ARGORITHM ] $ ARgorithm admin delete sample@user.com [SUCCESS]: DELETED ACCOUNT By default, this subcommand only deletes the user account (Refer here ). To delete the progammer account as well use the -p or --programmer flag. Warning It is not recommended to delete programmer accounts. Programmer accounts are useful for finding authors of ARgorithm. Try blacklist instead","title":"Delete"},{"location":"help/","text":"Drop an issue at the repository and add the question label. you can also get in touch with us yatharth.mathur@gmail.com alansandra2013@gmail.com vinay.valson@gmail.com utkarsh19sep@gmail.com","title":"Need help?"},{"location":"server/","text":"Setting up your own server \u00b6 ARgorithm has a common server endpoint where the community can create and contribute their own ARgorithms. This is by default the endpoint for the toolkit command line. But in case , a programmer wants to setup a local server for testing purposes or wants to setup a specific server for their class or organisation. The following steps are to be followed. System Requirements \u00b6 The server is built using FastAPI. The requirements for running the application is given below Python 3.6+ fastapi uvicorn gunicorn (for production use) jinja2 aiofiles python-multipart databases[sqlite] python-jose passlib[bcrypt] motor ARgorithmToolkit PyJWT To run it in production, use gunicorn to run as a production server. Docker-ce will be required if server image is being used Installation \u00b6 You can clone the git repository and install requirements from the requirements.txt file. $ git clone https://github.com/ARgorithm/Server.git Cloning into 'Server' ---> 100% $ cd Server/app $ pip install -r requirements.txt ---> 100% Successfully installed packages or you can pull the image $ docker pull alanjohn/argorithm-server Using default tag: latest latest: Pulling from alanjohn/argorithm-server ---> 100% Status: Downloaded new image alanjohn/argorithm-server Configuring the Server \u00b6 The application can be run in different modes In-app database No authentication or authorization services. Data stored using sqlite database. By default, it runs in this mode mongodb database No authentication or authorization services. Data stored in mongodb database of your choice. For this you will need to set some environment variables: DATABASE=mongodb DB_USERNAME=yourdbusername DB_PASSWORD=yourdbpassword DB_ENDPOINT=yourdbendpoint DB_PORT=27017 mongodb with auth Authorization on all basic routes. Data stored in mongodb database of your choice. This is an enhancement to the previous mode so along with the required envs previously. SECRET_KEY=yoursecretkey ADMIN_EMAIL=sample@email.com ADMIN_PASSWORD=test123 Check the Dockerfile for the default values of these environment variables. The repo comes with two docker compose configuration files docker-compose.local.yml : runs application in default mode version : \"3\" services : arserver : image : alanjohn/argorithm-server:latest ports : - 80:80 volumes : - local-uploads:/app/app/uploads volumes : local-uploads : driver : local docker-compose.prod.yml : runs application with mongodb and auth and will setup mongodb database as well. will read env variables from .env file version : \"3\" services : mongodb : image : mongo ports : - 27017:27017 environment : - MONGO_INITDB_ROOT_USERNAME=${DB_USERNAME} - MONGO_INITDB_ROOT_PASSWORD=${DB_PASSWORD} volumes : - mongo-data:/data/db arserver : image : alanjohn/argorithm-server:latest ports : - 80:80 environment : - DATABASE=MONGO - AUTH=ENABLED - SECRET_KEY=${SECRET_KEY} - DB_USERNAME=${DB_USERNAME} - DB_PASSWORD=${DB_PASSWORD} - DB_ENDPOINT=mongodb - DB_PORT=27017 - ADMIN_EMAIL=${ADMIN_EMAIL} - ADMIN_PASSWORD=${PASSWORD} volumes : - uploads:/app/app/uploads depends_on : - mongoexp volumes : mongo-data : driver : local uploads : driver : local The environment variables in above compose files are read from .env file.You can create strong secret keys using $ openssl rand -hex 32 09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7 Running the server \u00b6 Running the application using uvicorn $ uvicorn main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [28720] INFO: Started server process [28722] INFO: Waiting for application startup. INFO: Application startup complete. Running the application as a docker container $ docker run --name -d server -p 80 :80 --env-file = .env alanjohn/argorithm-server:latest server Running the application using docker-compose $ docker-compose -f docker-compose.prod.yml up Creating network \"server_default\" with the default driver Creating server_mongodb_1 ... done Creating server_arserver_1 ... done Attaching to server_mongodb_1,server_arserver_1 Interacting with server \u00b6 Once the server is running, you can check whether its running by entering the public IP on the browswer. You should get the server running page. you can check the api routes on /docs page with help of FastAPI Swagger UI. You can get the api routes in json format at the /openapi.json . There are two type of accounts in the server: Programmer User The programmer account allows you to create and manage argorithms. The user account allows you to run argorithms and get states. When using the CLI account new command, it create both a progammer and a user account for that email. The mobile application can only create user accounts. logs are generated in server.log file which you will find in \\uploads . The server.log file contains request based logs for every path. The process.log has logs regarding state generation for argorithm.","title":"Server Setup"},{"location":"server/#setting-up-your-own-server","text":"ARgorithm has a common server endpoint where the community can create and contribute their own ARgorithms. This is by default the endpoint for the toolkit command line. But in case , a programmer wants to setup a local server for testing purposes or wants to setup a specific server for their class or organisation. The following steps are to be followed.","title":"Setting up your own server"},{"location":"server/#system-requirements","text":"The server is built using FastAPI. The requirements for running the application is given below Python 3.6+ fastapi uvicorn gunicorn (for production use) jinja2 aiofiles python-multipart databases[sqlite] python-jose passlib[bcrypt] motor ARgorithmToolkit PyJWT To run it in production, use gunicorn to run as a production server. Docker-ce will be required if server image is being used","title":"System Requirements"},{"location":"server/#installation","text":"You can clone the git repository and install requirements from the requirements.txt file. $ git clone https://github.com/ARgorithm/Server.git Cloning into 'Server' ---> 100% $ cd Server/app $ pip install -r requirements.txt ---> 100% Successfully installed packages or you can pull the image $ docker pull alanjohn/argorithm-server Using default tag: latest latest: Pulling from alanjohn/argorithm-server ---> 100% Status: Downloaded new image alanjohn/argorithm-server","title":"Installation"},{"location":"server/#configuring-the-server","text":"The application can be run in different modes In-app database No authentication or authorization services. Data stored using sqlite database. By default, it runs in this mode mongodb database No authentication or authorization services. Data stored in mongodb database of your choice. For this you will need to set some environment variables: DATABASE=mongodb DB_USERNAME=yourdbusername DB_PASSWORD=yourdbpassword DB_ENDPOINT=yourdbendpoint DB_PORT=27017 mongodb with auth Authorization on all basic routes. Data stored in mongodb database of your choice. This is an enhancement to the previous mode so along with the required envs previously. SECRET_KEY=yoursecretkey ADMIN_EMAIL=sample@email.com ADMIN_PASSWORD=test123 Check the Dockerfile for the default values of these environment variables. The repo comes with two docker compose configuration files docker-compose.local.yml : runs application in default mode version : \"3\" services : arserver : image : alanjohn/argorithm-server:latest ports : - 80:80 volumes : - local-uploads:/app/app/uploads volumes : local-uploads : driver : local docker-compose.prod.yml : runs application with mongodb and auth and will setup mongodb database as well. will read env variables from .env file version : \"3\" services : mongodb : image : mongo ports : - 27017:27017 environment : - MONGO_INITDB_ROOT_USERNAME=${DB_USERNAME} - MONGO_INITDB_ROOT_PASSWORD=${DB_PASSWORD} volumes : - mongo-data:/data/db arserver : image : alanjohn/argorithm-server:latest ports : - 80:80 environment : - DATABASE=MONGO - AUTH=ENABLED - SECRET_KEY=${SECRET_KEY} - DB_USERNAME=${DB_USERNAME} - DB_PASSWORD=${DB_PASSWORD} - DB_ENDPOINT=mongodb - DB_PORT=27017 - ADMIN_EMAIL=${ADMIN_EMAIL} - ADMIN_PASSWORD=${PASSWORD} volumes : - uploads:/app/app/uploads depends_on : - mongoexp volumes : mongo-data : driver : local uploads : driver : local The environment variables in above compose files are read from .env file.You can create strong secret keys using $ openssl rand -hex 32 09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7","title":"Configuring the Server"},{"location":"server/#running-the-server","text":"Running the application using uvicorn $ uvicorn main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [28720] INFO: Started server process [28722] INFO: Waiting for application startup. INFO: Application startup complete. Running the application as a docker container $ docker run --name -d server -p 80 :80 --env-file = .env alanjohn/argorithm-server:latest server Running the application using docker-compose $ docker-compose -f docker-compose.prod.yml up Creating network \"server_default\" with the default driver Creating server_mongodb_1 ... done Creating server_arserver_1 ... done Attaching to server_mongodb_1,server_arserver_1","title":"Running the server"},{"location":"server/#interacting-with-server","text":"Once the server is running, you can check whether its running by entering the public IP on the browswer. You should get the server running page. you can check the api routes on /docs page with help of FastAPI Swagger UI. You can get the api routes in json format at the /openapi.json . There are two type of accounts in the server: Programmer User The programmer account allows you to create and manage argorithms. The user account allows you to run argorithms and get states. When using the CLI account new command, it create both a progammer and a user account for that email. The mobile application can only create user accounts. logs are generated in server.log file which you will find in \\uploads . The server.log file contains request based logs for every path. The process.log has logs regarding state generation for argorithm.","title":"Interacting with server"},{"location":"start/","text":"You can install the ARgorithmToolkit using pip $ pip install ARgorithmToolkit ---> 100% Successfully installed ARgorithmToolkit You can setup auto completion for your shell by using --install-completion option provided by Typer . After that you can get started with your own ARgorithm $ ARgorithm init hello_world Creating empty template for hello_world [SUCCESS]: TEMPLATE GENERATED refer documentation at https://argorithm.github.io/toolkit/ to learn how to use it chech out examples at https://github.com/ARgorithm/toolkit/tree/master/examples $ ls hello_world.config.json hello_world.py This will generate your .py file and your .config.json file. The <name>.py file will store your code that you will submit to the server hosting all ARgorithms The <name>.config.json stores important details about your ARgorithm such as its purpose and parameters required The <name>.py file initially looks like this import ARgorithmToolkit def run ( ** kwargs ): stateset = ARgorithmToolkit . StateSet () # # Your code # return You can add whatever code you want to this file using all the tools and classes present in ARgorithmToolkit but be sure that Your file should have one function which takes **kwargs input (refer here to know more about kwargs) that will should perform whatever you desire and should return the stateset. You can check out later in the document on how to use this stateset you can create classes and additional functions in your code. Support for importing external modules is not yet added so its advisable not to add those. the <name>.config.json file is a JSON file storing all the metadata { \"argorithmID\" : \"<name>\" , \"file\" : \"<name>.py\" , \"function\" : \"<function to be called>\" , \"parameters\" : { \"variable-name\" : \"<data-type>\" } , \"default\" : { \"variable-name\" : \"<value>\" }, \"description\" : \"Tell us about your ARgorithm\" } Key Description argorithmID name of your ARgorithm , this is generally pre filled from when you run the init command. The name of your code file should be name .py and the config should be name .config.json. [will be fixed later] file The file containing your codefile function The function that is going to be called parameters the parameters that your ARgorithm would need, this helps in anyone using your ARgorithm to understand what is the input format default default parameters in case no parameters are passed description The description of ARgorithm. Helpful to people using your ARgorithm as well as other developers You can check out ARgorithm examples in our Github Repo. Check out the commandline interface for more details Using ARgorithmToolkit \u00b6 ARgorithmToolkit adds a few extra steps when it comes to initializing instances whose states you want to record but thats because a lot of data has to be maintained in order for smooth transitions >>> import ARgorithmToolkit >>> algo = ARgorithmToolkit . StateSet () >>> x = ARgorithmToolkit . Variable ( 'x' , algo , 0 , comments = 'Our first variable' ) >>> x . value 0 >>> x . value += 10 >>> x . value 10 >>> print ( algo ) { 'state_type' : 'variable_declare' , 'state_def' : { 'variable_name' : 'x' , 'value' : 0 }, 'comments' : 'Our first variable' } { 'state_type' : 'variable_highlight' , 'state_def' : { 'variable_name' : 'x' , 'value' : 10 }, 'comments' : '' } As ARgorithm is tool for creating visual demonstration , you can add comments parameter to most functions. These comments get included in states and get featured as text when that state is rendered in AR. Make sure you design the objects you want to keep track of as part of the same stateset. Each object is instantiated with a name this is important to identify arrays when rendering them You can refer the docs and samples in the repo to understand more clearly. StateSet \u00b6 The core class to all algorithm and data structures in ARgorithmToolkit You will always need a object of this class when using different ARgorithmToolkit features. This is where the states are stored that later get rendered to ARgorithm App. So obviously all your ARgorithms are supposed to return this You wont have to interact with it much other than while initialising objects and returning results. It has a add_comment method that allows you to create blank states carrying description in the form of comments that you might want to show to the client while the ARgorithm is being rendered. This will prove handy when creating good demonstrations >>> import ARgorithmToolkit >>> algo = ARgorithmToolkit . StateSet () >>> algo . add_comment ( \"Hello world\" ) >>> print ( algo ) { 'state_type' : 'comment' , 'state_def' : None , 'comments' : 'Hello world' }","title":"Getting Started"},{"location":"start/#using-argorithmtoolkit","text":"ARgorithmToolkit adds a few extra steps when it comes to initializing instances whose states you want to record but thats because a lot of data has to be maintained in order for smooth transitions >>> import ARgorithmToolkit >>> algo = ARgorithmToolkit . StateSet () >>> x = ARgorithmToolkit . Variable ( 'x' , algo , 0 , comments = 'Our first variable' ) >>> x . value 0 >>> x . value += 10 >>> x . value 10 >>> print ( algo ) { 'state_type' : 'variable_declare' , 'state_def' : { 'variable_name' : 'x' , 'value' : 0 }, 'comments' : 'Our first variable' } { 'state_type' : 'variable_highlight' , 'state_def' : { 'variable_name' : 'x' , 'value' : 10 }, 'comments' : '' } As ARgorithm is tool for creating visual demonstration , you can add comments parameter to most functions. These comments get included in states and get featured as text when that state is rendered in AR. Make sure you design the objects you want to keep track of as part of the same stateset. Each object is instantiated with a name this is important to identify arrays when rendering them You can refer the docs and samples in the repo to understand more clearly.","title":"Using ARgorithmToolkit"},{"location":"start/#stateset","text":"The core class to all algorithm and data structures in ARgorithmToolkit You will always need a object of this class when using different ARgorithmToolkit features. This is where the states are stored that later get rendered to ARgorithm App. So obviously all your ARgorithms are supposed to return this You wont have to interact with it much other than while initialising objects and returning results. It has a add_comment method that allows you to create blank states carrying description in the form of comments that you might want to show to the client while the ARgorithm is being rendered. This will prove handy when creating good demonstrations >>> import ARgorithmToolkit >>> algo = ARgorithmToolkit . StateSet () >>> algo . add_comment ( \"Hello world\" ) >>> print ( algo ) { 'state_type' : 'comment' , 'state_def' : None , 'comments' : 'Hello world' }","title":"StateSet"},{"location":"tutorials/","text":"Tutorials \u00b6 This section demonstrates how argorithms are created to visualize data structures and algorithm in augmented reality. All the files used in this section can be found here . Before we see and implement some examples, it is important to understand the functioning of ARgorithmToolkit and what all data does an argorithm require to create dynamic AR visualisations. Creating the template \u00b6 The ARgorithmToolkit CLI comes with the init command to generate a blank template for your argorithm $ ARgorithm init hello_world Creating empty template for hello_world [SUCCESS]: TEMPLATE GENERATED refer documentation at https://argorithm.github.io/toolkit/ to learn how to use it chech out examples at https://github.com/ARgorithm/toolkit/tree/master/examples $ ls hello_world.config.json hello_world.py This creates the .config.json file and the .py file required to run the states. These files were covered in detail in the getting started page . All the examples in this tutorials will be starting from this step onwards. Executing the code \u00b6 One thing to be kept in mind while running an argorithm code file is that what you want to return is the output of the object but the stateset called. Thus, it becomes fundamentally important to be able to decipher stateset. The Stateset is an list of State objects. Each state is an event that occurs during the execution of the program. { 'state_type' : 'TYPE1' , 'state_def' : { 'DEF1' }, 'comments' : 'COMMENTS1' }, { 'state_type' : 'TYPE2' , 'state_def' : { 'DEF2' }, 'comments' : '' } ,{ 'state_type' : 'TYPE3' , 'state_def' : { 'DEF3' }, 'comments' : 'COMMENTS3' } The state_type is a literal used by the AR application to classify what kind of event is this. The state_type by convention is of the form <structure>_<method> like array_iter , stack_push etc. The state_def gives data about the particular event. The comments are used to add descriptive text to the AR visualisation. You can refer all the state types and what they do in the designs folder","title":"Introduction"},{"location":"tutorials/#tutorials","text":"This section demonstrates how argorithms are created to visualize data structures and algorithm in augmented reality. All the files used in this section can be found here . Before we see and implement some examples, it is important to understand the functioning of ARgorithmToolkit and what all data does an argorithm require to create dynamic AR visualisations.","title":"Tutorials"},{"location":"tutorials/#creating-the-template","text":"The ARgorithmToolkit CLI comes with the init command to generate a blank template for your argorithm $ ARgorithm init hello_world Creating empty template for hello_world [SUCCESS]: TEMPLATE GENERATED refer documentation at https://argorithm.github.io/toolkit/ to learn how to use it chech out examples at https://github.com/ARgorithm/toolkit/tree/master/examples $ ls hello_world.config.json hello_world.py This creates the .config.json file and the .py file required to run the states. These files were covered in detail in the getting started page . All the examples in this tutorials will be starting from this step onwards.","title":"Creating the template"},{"location":"tutorials/#executing-the-code","text":"One thing to be kept in mind while running an argorithm code file is that what you want to return is the output of the object but the stateset called. Thus, it becomes fundamentally important to be able to decipher stateset. The Stateset is an list of State objects. Each state is an event that occurs during the execution of the program. { 'state_type' : 'TYPE1' , 'state_def' : { 'DEF1' }, 'comments' : 'COMMENTS1' }, { 'state_type' : 'TYPE2' , 'state_def' : { 'DEF2' }, 'comments' : '' } ,{ 'state_type' : 'TYPE3' , 'state_def' : { 'DEF3' }, 'comments' : 'COMMENTS3' } The state_type is a literal used by the AR application to classify what kind of event is this. The state_type by convention is of the form <structure>_<method> like array_iter , stack_push etc. The state_def gives data about the particular event. The comments are used to add descriptive text to the AR visualisation. You can refer all the state types and what they do in the designs folder","title":"Executing the code"},{"location":"tutorials/bubblesort/","text":"Bubblesort \u00b6 This tutorial looks towards creating AR visualisation of bubblesort using ARgorithm. Bubblesort is one of the most basic sorting algorithms. Writing the code \u00b6 This is the argorithm code for bubblesort. As you can see other than some differences in object creation and methods. The core logic behind the algorithm remains unchanged and the lines of code are not very different from the normal implementation of bubblesort. def check ( a , b ): return a > b def run ( ** kwargs ): arr = kwargs [ 'array' ] for i in range ( 0 , len ( arr )): for j in range ( i + 1 , len ( arr )): if check ( arr [ i ], arr [ j ]): arr [ i ], arr [ j ] = arr [ j ], arr [ i ] return array import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo The StateSet Object \u00b6 Lets break down the differences. as we mentioned before for an argorithm to able to record states, we need an object of type StateSet and that is what our ARgorithm should return and not the output of the algorithm. The output of the algorithm if not specified with any of the states can be appended to the stateset. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo Using the ARgorithm STL \u00b6 For ARgorithm to listen to the state changes you need to implement the containers and objects that you want rendered using the classes provided in ARgorithmToolkit. We have an array here on which we have to show bubblesort so insteaed of using list , we will use the ARgorithmToolkit.Array . The constructor for the Array class will take the stateset and the array. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo Now whenever the values of array are accessed or altered, the stateset will record the events. The Array class can be indexed normally as a list would be. The Array class comes with built-in functions that are not only useful but create special states that can be used to create more powerful animations. For eg. we can just index the array elements and compare them and swap their values as done in a normal bubblesort but by using the Array.compare and Array.swap we get the same functionalities and create more animations. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo Adding comments \u00b6 The goal of ARgorithm is to create visualisations for educational purposes. Thus textual hints that can be showed along with AR powered visualisations make them easier to understand. We highly recommend that comments be used wherver required to make clearer visualisations. You can add your comments in your method calls or use the add_comment method. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo Setting up the config file \u00b6 Now that your argorithm is ready, it's time to configure the bubblesort.config.json . argorithmID and file is already filled and need not be altered. The function is set to run which is the function from the file we need to call. The description stored description of the agorithm. These are useful metadata for the CLI and server when it comes to parsing and execution. The most important keys are parameters and default . parameters : This key stores an object where each key is a key for the function **kwargs and its value is the type of value expected. default : This key stores an object that specifies the default value for function **kwargs . These values would be used to in case of any exception in executing parameters. Info The keys inside the parameters and default objects must be the same { \"argorithmID\" : \"bubblesort\" , \"file\" : \"bubblesort.py\" , \"function\" : \"run\" , \"parameters\" : { \"array\" : \"list\" }, \"default\" : { \"array\" : [ 6 , 3 , 2 , 4 , 5 , 1 ] }, \"description\" : \"demonstrate bubble sort\" Now that we are done, we can submit the file to the server $ ARgorithm submit bubblesort [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED","title":"Bubblesort"},{"location":"tutorials/bubblesort/#bubblesort","text":"This tutorial looks towards creating AR visualisation of bubblesort using ARgorithm. Bubblesort is one of the most basic sorting algorithms.","title":"Bubblesort"},{"location":"tutorials/bubblesort/#writing-the-code","text":"This is the argorithm code for bubblesort. As you can see other than some differences in object creation and methods. The core logic behind the algorithm remains unchanged and the lines of code are not very different from the normal implementation of bubblesort. def check ( a , b ): return a > b def run ( ** kwargs ): arr = kwargs [ 'array' ] for i in range ( 0 , len ( arr )): for j in range ( i + 1 , len ( arr )): if check ( arr [ i ], arr [ j ]): arr [ i ], arr [ j ] = arr [ j ], arr [ i ] return array import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo","title":"Writing the code"},{"location":"tutorials/bubblesort/#the-stateset-object","text":"Lets break down the differences. as we mentioned before for an argorithm to able to record states, we need an object of type StateSet and that is what our ARgorithm should return and not the output of the algorithm. The output of the algorithm if not specified with any of the states can be appended to the stateset. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo","title":"The StateSet Object"},{"location":"tutorials/bubblesort/#using-the-argorithm-stl","text":"For ARgorithm to listen to the state changes you need to implement the containers and objects that you want rendered using the classes provided in ARgorithmToolkit. We have an array here on which we have to show bubblesort so insteaed of using list , we will use the ARgorithmToolkit.Array . The constructor for the Array class will take the stateset and the array. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo Now whenever the values of array are accessed or altered, the stateset will record the events. The Array class can be indexed normally as a list would be. The Array class comes with built-in functions that are not only useful but create special states that can be used to create more powerful animations. For eg. we can just index the array elements and compare them and swap their values as done in a normal bubblesort but by using the Array.compare and Array.swap we get the same functionalities and create more animations. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo","title":"Using the ARgorithm STL"},{"location":"tutorials/bubblesort/#adding-comments","text":"The goal of ARgorithm is to create visualisations for educational purposes. Thus textual hints that can be showed along with AR powered visualisations make them easier to understand. We highly recommend that comments be used wherver required to make clearer visualisations. You can add your comments in your method calls or use the add_comment method. import ARgorithmToolkit def check ( a , b ): return a > b def run ( ** kwargs ): algo = ARgorithmToolkit . StateSet () arr = ARgorithmToolkit . Array ( 'arr' , algo , data = kwargs [ 'array' ], comments = \"This is our unsorted array\" ) for i in range ( 0 , len ( arr )): algo . add_comment ( f \"Iterating the array starting from the { i } th index\" ) for j in range ( i + 1 , len ( arr )): if arr . compare ( i , j , check , comments = f \"comparing the { i } th and { j } th element\" ): arr . swap ( i , j , comments = f \"as arr[ { i } ] > arr[ { j } ] , we swap them\" ) return algo","title":"Adding comments"},{"location":"tutorials/bubblesort/#setting-up-the-config-file","text":"Now that your argorithm is ready, it's time to configure the bubblesort.config.json . argorithmID and file is already filled and need not be altered. The function is set to run which is the function from the file we need to call. The description stored description of the agorithm. These are useful metadata for the CLI and server when it comes to parsing and execution. The most important keys are parameters and default . parameters : This key stores an object where each key is a key for the function **kwargs and its value is the type of value expected. default : This key stores an object that specifies the default value for function **kwargs . These values would be used to in case of any exception in executing parameters. Info The keys inside the parameters and default objects must be the same { \"argorithmID\" : \"bubblesort\" , \"file\" : \"bubblesort.py\" , \"function\" : \"run\" , \"parameters\" : { \"array\" : \"list\" }, \"default\" : { \"array\" : [ 6 , 3 , 2 , 4 , 5 , 1 ] }, \"description\" : \"demonstrate bubble sort\" Now that we are done, we can submit the file to the server $ ARgorithm submit bubblesort [SUCCESS]: FILES FOUND [SUCCESS]: FILES VERIFIED [SUCCESS]: SUBMITTED","title":"Setting up the config file"},{"location":"tutorials/fibonacci/","text":"","title":"Fibonacci"}]}